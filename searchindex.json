{"categories":[{"title":"docker","uri":"https://healinyoon.github.io/categories/docker/"},{"title":"go","uri":"https://healinyoon.github.io/categories/go/"},{"title":"hugo","uri":"https://healinyoon.github.io/categories/hugo/"},{"title":"jenkins","uri":"https://healinyoon.github.io/categories/jenkins/"},{"title":"kubernetes","uri":"https://healinyoon.github.io/categories/kubernetes/"}],"posts":[{"content":"Intro Kubernetes에서 GPU를 사용하도록 환경을 구축하고 사용해보자. 여기서는 Kubernest 클러스터가 구축되어 있다고 전제하고 진행한다. 아직 설치가 되지 않았다면 Kubernetes Cluster 설치하기(ubuntu18.04)을 참고해서 설치 후 진행해야 한다.\n ","id":0,"section":"posts","summary":"Intro Kubernetes에서 GPU를 사용하도록 환경을 구축하고 사용해보자. 여기서는 Kubernest 클러스터가 구축되어 있다고 전제하고 진행한다. 아직 설치가 되지 않았","tags":null,"title":"Kubernets(쿠버네티스) with GPU 구축하기","uri":"https://healinyoon.github.io/2020/10/20201023_kubernetes_with_gpu/","year":"2020"},{"content":"Intro 회사에서 쿠버네티스 업무를 하다가 \u0026ldquo;쿠버네티스 위에서도 GPU 성능이 보장되는가?\u0026ldquo;라는 질문이 나왔다. 쿠버네티스 운영 중에 자주 마주하는 질문이므로, 이번 기회에 정리를 해보려고 한다.\n","id":1,"section":"posts","summary":"Intro 회사에서 쿠버네티스 업무를 하다가 \u0026ldquo;쿠버네티스 위에서도 GPU 성능이 보장되는가?\u0026ldquo;라는 질문이 나왔다. 쿠버네티스 운영 중에 자주 마","tags":null,"title":"GPU 성능 비교하기: Host vs K8S","uri":"https://healinyoon.github.io/2020/10/20201023_gpu_performance_host_vs_container/","year":"2020"},{"content":"배경 회사에서 Kubernetes를 운영하다보면 클러스터에 새로운 worker node를 추가해야하는 일이 종종 생깁니다.\n문제는 apt-get 등 기본 패키지 관리 도구를 사용하여 생각 없이 설치하면 기존에 운영하던 k8s 클러스터 버전과 맞지 않은 최신 버전이 설치 된다는 것입니다\u0026hellip;(~그러면 저처럼 작업을 2번 하게 됩니다 하하~)\n그런데 바이너리 파일을 사용해서 설치하기는 또 귀찮고..\n따라서 apt를 사용하되, 버전을 옵션으로 주는 방식으로 설치를 하기로 했습니다.\n나중에 또 2번 작업하지 않기 위해서, 그리고 중간에 발생한 이슈도 기록해둘겸 내용을 정리하였습니다.\n설치하기 사실 기존 k8s 클러스터 설치 프로세스와 다른 점은 거의 없습니다. 기존의 프로세스는 여기를 참고 바랍니다.\n특정 버전 설치 옵션을 주는 부분만 신경써서 진행하면 됩니다.\n# cat \u0026lt;\u0026lt;EOF | sudo tee /etc/apt/sources.list.d/kubernetes.list deb https://apt.kubernetes.io/ kubernetes-xenial main EOF sudo apt-get update sudo apt-get install -y kubelet kubeadm kubectl // 패키지가 자동으로 업그레이드 되지 않도록 설정 sudo apt-mark hold kubelet kubeadm kubectl  원래는 아래와 같이 그냥 최신 버전을 설치했다면 이번엔 옵션으로 버전을 줘야 합니다. sudo apt-get install -y kubelet kubeadm kubectl  운영 중인 클러스터의 버전 확인하자 먼저 기존에 운영 중인 k8s 클러스터의 버전을 확인합니다.\nroot@hci-k8s-master-01:~# kubectl get nodes NAME STATUS ROLES AGE VERSION k8s-worker-01 Ready \u0026lt;none\u0026gt; 74d v1.18.8 k8s-worker-02 Ready \u0026lt;none\u0026gt; 74d v1.18.8 k8s-master-01 Ready master 76d v1.18.6  클러스터의 node들은 1.18.x 버전을 사용하는 것을 알 수 있습니다.\n버전을 확인했으니 이제 설치를 진행합니다.\n설치 가능한 버전 확인하기 저는 sudo apt-get install -y kubelet=1.18.8 이렇게 옵션을 주고 설치하려고 했는데, 애석하게도 실패했습니다.\n아래와 같은 로그가 발생합니다.\n# sudo apt-get install kubelet=1.18.8 Reading package lists... Done Building dependency tree Reading state information... Done E: Version '1.18.8' for 'kubelet' was not found  정확한 버전 옵션을 확인해보도록 합니다.\n# apt-cache madison kubeadm  출력 결과에 제가 사용하려던 1.18.8 버전은 다음과 같이 나와있습니다.\nkubeadm | 1.18.8-00 | https://apt.kubernetes.io kubernetes-xenial/main amd64 Packages  1.18.8-00 버전으로 설치하기 이제 다시 설치를 진행해봅니다.\n kubeadm 설치 원래 kubeadm만 설치해도 kubectl과 kubelet이 의존적으로 설치됩니다.\n그런데 말입니다\u0026hellip; 특이점이 발생합니다.  # sudo apt-get install kubeadm=1.18.8-00 Reading package lists... Done Building dependency tree Reading state information... Done The following additional packages will be installed: kubectl The following NEW packages will be installed: kubeadm kubectl 0 upgraded, 2 newly installed, 0 to remove and 5 not upgraded. Need to get 0 B/16.5 MB of archives. After this operation, 82.8 MB of additional disk space will be used. Do you want to continue? [Y/n] Y Selecting previously unselected package kubectl. (Reading database ... 128167 files and directories currently installed.) Preparing to unpack .../kubectl_1.19.2-00_amd64.deb ... Unpacking kubectl (1.19.2-00) ... Selecting previously unselected package kubeadm. Preparing to unpack .../kubeadm_1.18.8-00_amd64.deb ... Unpacking kubeadm (1.18.8-00) ... Setting up kubectl (1.19.2-00) ... Setting up kubeadm (1.18.8-00) ...  위와 같이 kubectl이 1.19.2-00 버전으로 설치가 됩니다. 찜찜하니까 downgrade 해줍니다.\n# apt-get install kubectl=1.18.8-00 Reading package lists... Done Building dependency tree Reading state information... Done The following packages will be DOWNGRADED: kubectl 0 upgraded, 0 newly installed, 1 downgraded, 0 to remove and 6 not upgraded. Need to get 8,827 kB of archives. After this operation, 1,036 kB of additional disk space will be used. Do you want to continue? [Y/n] Y Get:1 https://packages.cloud.google.com/apt kubernetes-xenial/main amd64 kubectl amd64 1.18.8-00 [8,827 kB] Fetched 8,827 kB in 9s (1,024 kB/s) dpkg: warning: downgrading kubectl from 1.19.2-00 to 1.18.8-00 (Reading database ... 128169 files and directories currently installed.) Preparing to unpack .../kubectl_1.18.8-00_amd64.deb ... Unpacking kubectl (1.18.8-00) over (1.19.2-00) ... Setting up kubectl (1.18.8-00) ...  Master에 join하기 참고와 동일하게 진행한다.\n-끝-\n","id":2,"section":"posts","summary":"배경 회사에서 Kubernetes를 운영하다보면 클러스터에 새로운 worker node를 추가해야하는 일이 종종 생깁니다. 문제는 apt-get 등 기본 패키지 관리 도구를 사용하","tags":["msa","k8s"],"title":"Kuberenets 특정 버전으로 설치하기","uri":"https://healinyoon.github.io/2020/10/20201009_k8s_install_specific_version/","year":"2020"},{"content":"Kubernetes Cluster 설치하기 이 페이지에서는 ubuntu18.04에 kubeadm tool을 설치하고 이를 사용하여 kubernetes cluster를 구축하는 방법을 정리했습니다.\n구성 H/W 구성하려는 kubernetes cluster는 다음과 같습니다.\n   노드 vCPU RAM Disk     master01 2 8GiB    worker01 2 8GiB    worker02 2 8GiB     Required ports 1) Control-plane node(s) 2) Worker node(s) Docker 설치(모든 node) # curl -fsSL https://get.docker.com/ | sudo sh # systemctl start docker # systemctl enable docker  Kubernetes 클러스터 구성 쿠버네티스 공식 사이트 kubeam 설치\n모든 노드에 아래의 패키지를 설치한다.\n kubeadm: 클러스터를 부트스트랩하는 명령(쿠버네티스 관리) kubelet: 클러스터의 모든 시스템에서 실행되는 구성 요소로, 포트 및 컨테이너 시작과 같은 작업을 수행(쿠버네티스 서비스) kubectl: 클러스터와 통신하기 위한 command line util(쿠버네티스 클라이언트 프로그램, 클러스터 구성과는 전혀 상관 없음)  1) Kubernetes 리포지토리 구성(모든 node) # sudo apt-get update \u0026amp;\u0026amp; sudo apt-get install -y apt-transport-https curl curl -s https://packages.cloud.google.com/apt/doc/apt-key.gpg | sudo apt-key add -  2) Kubeadm, Kubelet, Kubectl 설치(모든 node) # cat \u0026lt;\u0026lt;EOF | sudo tee /etc/apt/sources.list.d/kubernetes.list deb https://apt.kubernetes.io/ kubernetes-xenial main EOF sudo apt-get update sudo apt-get install -y kubelet kubeadm kubectl // 패키지가 자동으로 업그레이드 되지 않도록 설정 sudo apt-mark hold kubelet kubeadm kubectl // 데몬 재시작 systemctl daemon-reload systemctl restart kubelet  3) hostname 등록 # sudo hostnamectl set-hostname master01 또는 # sudo hostnamectl set-hostname worker01  4) /etc/hosts 파일 수정 # vi /etc/hosts 아래에 추가 {IP} master01 {IP} worker01 {IP} worker02  5) Iptables 설정 브릿지 되어있는 IPv4 트래픽을 iptables 체인으로 전달될 수 있도록 한다.\n# cat \u0026lt;\u0026lt;EOF | sudo tee /etc/sysctl.d/k8s.conf net.bridge.bridge-nf-call-ip6tables = 1 net.bridge.bridge-nf-call-iptables = 1 EOF # sudo sysctl --system  6) 스왑 기능 비활성화 swap 끄기 # sudo swapoff -a 재부팅 후에도 swap 설정 유지 # sudo sed -i '/ swap / s/^\\(.*\\)$/#\\1/g' /etc/fstab  7) 마스터 노드 초기화 # kubeadm init  kubeadm init 명령어 실행시 아래와 같이 출력된다.\nTo start using your cluster, you need to run the following as a regular user: mkdir -p $HOME/.kube sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config sudo chown $(id -u):$(id -g) $HOME/.kube/config You should now deploy a pod network to the cluster. Run \u0026quot;kubectl apply -f [podnetwork].yaml\u0026quot; with one of the options listed at: https://kubernetes.io/docs/concepts/cluster-administration/addons/ Then you can join any number of worker nodes by running the following on each as root: kubeadm join 10.1.11.4:6443 --token xxxxxxxxxxxxxxxxxxxxxxx \\ --discovery-token-ca-cert-hash sha256:e184c470296359bc4a35bc57624b03d8c4b3eb2bd46f413f3a68a86f182c9844  master node에서 아래 명령어를 수행하고\n$ mkdir -p $HOME/.kube $ sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config $ sudo chown $(id -u):$(id -g) $HOME/.kube/config  worker node에서 아래의 명령어를 수행하여 master node와 join한다.\nkubeadm join 10.1.11.4:6443 --token xxxxxxxxxxxxxxxxxxxxxxx \\ --discovery-token-ca-cert-hash sha256:e184c470296359bc4a35bc57624b03d8c4b3eb2bd46f413f3a68a86f182c9844  master node에서 kubectl get nodes 명령어를 입력하면 다음과 같이 출력된다.\n# kubectl get nodes NAME STATUS ROLES AGE VERSION healin-k8s-master01 NotReady master 10m v1.19.0 healin-k8s-worker01 NotReady \u0026lt;none\u0026gt; 30s v1.19.0 healin-k8s-worker02 NotReady \u0026lt;none\u0026gt; 29s v1.19.0  8) 네트워크 애플리케이션 설치 pod 네트워크 애플리케이션을 설치해야 클러스터 내의 node간 통신이 가능하다.\n사용 가능한 옵션은 여기에서 확인할 수 있다.\n다음 명령을 master node에서 수행하여 weave pod 네트워크 애플리케이션을 설치한다.\nkubectl apply -f \u0026quot;https://cloud.weave.works/k8s/net?k8s-version=$(kubectl version | base64 | tr -d '\\n')\u0026quot; 이런 오류 발생시 The connection to the server localhost:8080 was refused - did you specify the right host or port? export KUBECONFIG=/etc/kubernetes/admin.conf 을 적용해보자  master node에서 kubectl get nodes 명령어를 잠시 후 다시 입력하면 다음과 같이 STATUS가 NotReady =\u0026gt; Ready로 변경된 것을 확인할 수 있다.\n# kubectl get nodes NAME STATUS ROLES AGE VERSION healin-k8s-master01 Ready master 17m v1.19.0 healin-k8s-worker01 Ready \u0026lt;none\u0026gt; 7m42s v1.19.0 healin-k8s-worker02 Ready \u0026lt;none\u0026gt; 7m41s v1.19.0  9) master node를 worker node로도 사용하고 싶다면, 쿠버네티스 클러스터의 control-plane 노드는 보안상의 이유로 격리되어 있다(기본값). master node에서는 pod 가 스케줄링 되지 않으므로, 1대의 머신으로만 쿠버네티스 클러스터를 구축할 경우 격리 해제해야 한다.\n$ kubectl taint nodes –all node-role.kubernetes.io/master-  참고 쿠버네티스(kubernetes) 설치 및 환경 구성하기\n","id":3,"section":"posts","summary":"Kubernetes Cluster 설치하기 이 페이지에서는 ubuntu18.04에 kubeadm tool을 설치하고 이를 사용하여 kubernetes cluster를 구축하는 방법을 정리했습니다. 구성 H/W 구성하","tags":["msa","k8s"],"title":"Kubernetes Cluster 설치하기(ubuntu18.04)","uri":"https://healinyoon.github.io/2020/09/20200828_install_kubernetes_cluster_ubuntu/","year":"2020"},{"content":"Pod Network pod network가 헷갈려서 정리용으로 만든 페이지\n공식 사이트의 설명: Installing a Pod network add-on\n","id":4,"section":"posts","summary":"Pod Network pod network가 헷갈려서 정리용으로 만든 페이지 공식 사이트의 설명: Installing a Pod network add-on","tags":["msa","k8s","pod networks"],"title":"쿠버네티스 POD Network","uri":"https://healinyoon.github.io/2020/09/20200901_k8s_pod_network/","year":"2020"},{"content":"목적 Jenkins node heap memory 사이즈 변경 방법 정리\n참고 자료  Java Memory Management for Java Virtual Machine (JVM) Java Platform, Standard Edition HotSpot Virtual Machine Garbage Collection Tuning Guide CloudBees Jenkins JVM troubleshooting Jenkins 권장 사양  Jenkins Heap Memory 옵션 Jenkins에서는 다양한 JAVA 옵션을 인수로 받을 수 있음\nJenkins node heap memory 사이즈를 변경하기 위한 인수: -Xmx와 -Xms\n-Xms\u0026lt;size\u0026gt; set initial Java heap size -Xmx\u0026lt;size\u0026gt; set maximum Java heap size  예시 1) master의 /etc/default/jenkins에서 설정 AVA_ARGS=\u0026quot;-Xmx256m\u0026quot; # default value JAVA_ARGS=\u0026quot;-Xmx2048m\u0026quot; # 2048MB size  2) Jenkins UI에서 slave 설정 [Jenkins 관리] \u0026gt; [노드 관리] \u0026gt; \u0026lsquo;노드 선택 후 ' [설정] \u0026gt; [고급] Jenkins 권장 사양(자세히) 참고  It is recommended to define the same value for both -Xms and -Xmx so that the memory is allocated on startup rather than runtime. 대/소문자는 상관 없음(예: -Xmx10G는 -Xmx10g와 동일함) Java processes 전역에 적용하고 싶으면 JAVA_TOOL_OPTIONS 환경 변수 사용(예: export JAVA_TOOL_OPTIONS=\u0026quot;-Xmx6g\u0026quot;)  ","id":5,"section":"posts","summary":"목적 Jenkins node heap memory 사이즈 변경 방법 정리 참고 자료 Java Memory Management for Java Virtual Machine (JVM) Java Platform, Standard Edition HotSpot Virtual Machine Garbage Collection Tuning Guide CloudBees Jenkins JVM troubleshooting Jenkins 권장 사양 Jenkins Heap Memory 옵션 Jenkins에서는 다양한 JAVA 옵션을 인","tags":["ci/cd","jvm"],"title":"Jenkins Node Heap Memory 사이즈 설정하기(-Xmx/-Xms 옵션)","uri":"https://healinyoon.github.io/2020/08/20200831_jenkins_node_heap_size/","year":"2020"},{"content":"Jenkins Master-Slave Jenkins는 기본적으로 단일 서버로 동작합니다. 그러나 단일 서버는 다음과 같은 상황을 충족하기 충분하지 않습니다.\n 빌드 테스트를 위한 다양한 환경이 필요한 경우 크고 무거운 프로젝트의 작업 부하를 분산해야하는 경우  위의 요구사항을 충족하기 위해 Jenknis 분산 아키텍처인 Master-Slave 구성이 도입되었습니다. Jenkins Master와 Slave의 역할    구분 역할     Master * Build 작업 예약* Build 실행을 위한 작업 분배* Slave node 모니터링(필요에 따라 on/offline 전환 가능)* Build 결과 기록   Slave * Jenkins Master의 요청 수신* Build 실행    Jenkins Master-Slave 연동 방법 Jenkins Master-Slave는 다음의 요구사항을 만족시키면 매우 간단하게 구성할 수 있습니다.\n Master 서버에서 Slave 서버에 접근 가능하도록 설정 Slave 서버의 Jenkins Java 요구사항 충족  1. Jenkins 사용자 생성(모든 Slave node에서 진행) # adduser jenkins 사용자 생성 후 다음과 같이 홈디렉토리의 권한을 변경해준다 # chown ldccai:jenkins /home/jenkins # chmod 775 /home/jenkins  2. Java 8 설치(모든 Slave node에서 진행) # apt-get install openjdk-8-jdk  3. Jenkins에서 Slave node 등록 등록된 노드의 [로그]를 확인하면 다음과 같이 Master 서버와 잘 연동된 것을 확인할 수 있습니다. ","id":6,"section":"posts","summary":"Jenkins Master-Slave Jenkins는 기본적으로 단일 서버로 동작합니다. 그러나 단일 서버는 다음과 같은 상황을 충족하기 충분하지 않습니다. 빌드 테스트를 위한 다양한 환경이 필","tags":["ci/cd","master-slave"],"title":"Jenkins Master-Slave 구성하기","uri":"https://healinyoon.github.io/2020/08/20200827_jenkins_master_slave/","year":"2020"},{"content":"CI/CD란 CI/CD는 애플리케이션 개발 단계를 자동화하여 보다 작은 코드 단위와 짧은 주기로 Test와 Build를 수행하고 고객에게 제공하는 방법을 의미합니다.\nCI(Continuous Integration): 지속적 통합 개발자의 변경 사항이 정기적으로(최상의 경우 하루 여러번) 빌드 및 테스트 되고 공유 리포지토리에 병합되는 프로세스입니다.\nCD(Continous Deploy or ontinuous Delivery): 지속적 배포 Jez Humble의 정의\nContinuous Deployment is about automating the release of a good build to the production environment. In fact, Humble thinks it might be more accurate to call it “continuous release.”\nContinuous Delivery is about 1) ensuring that every good build is potentially ready for production release. At the very least, 2) it’s sent to the user acceptance test (UAT) environment. 3) Your business team can then decide when a successful build in UAT can be deployed to production —and they can do so at the push of a button.\n상황에 따라 이미 운영되고 있는 프로덕션 환경에 바로 release 하는 것은 문제가 될 수 있습니다. 이러한 경우로 임베디드 소프트웨어 등이 해당됩니다.\n따라서 잠재적으로는 release 가능하지만, 프로덕션 환경에 자동으로 release 되지 않는 것이 Continuous Delivery 입니다. 정리  CI: 지속적인 빌드 / 테스트 / 통합 CD: CI의 연장선 ~ Release 준비 완료(Delivery) or 제품 출시(Deploy)   Jenkins for CI/CD 다양한 CI/CD tool CI/CD 구현을 위한 다양한 tool이 있습니다. tool에 대한 자세한 정보 참고\n왜 Jenkins인가 Jenkins는 아래와 같은 강점을 가지고 있습니다.\n It is an open-source tool with great community support. It is easy to install. It has 1000+ plugins to ease your work. If a plugin does not exist, you can code it and share it with the community. It is free of cost. It is built with Java and hence, it is portable to all the major platforms.  하지만 단점 역시 존재합니다. CI/CD tool 중에서 자주 사용되는 Jenkins vs Gitlab vs Travis 비교 글을 참고하시면 Jenkins의 장단점을 이해하는데 도움이 됩니다.\n","id":7,"section":"posts","summary":"CI/CD란 CI/CD는 애플리케이션 개발 단계를 자동화하여 보다 작은 코드 단위와 짧은 주기로 Test와 Build를 수행하고 고객에게 제공하는 방법을 의미","tags":["ci/cd"],"title":"CI/CD와 Jenkins","uri":"https://healinyoon.github.io/2020/08/20200827_cicd_and_jenkins/","year":"2020"},{"content":"HUGO 글 생성하기 $ hugo new {파일명}  HUGO 블로그 빌드 $ hugo -t {테마명}  Git push $ cd public $ git add . $ git commit -m \u0026quot;{commit 메세지}\u0026quot; $ git push origin master $ cd .. $ git add . $ git commit -m \u0026quot;{commit 메세지}\u0026quot; $ git push origin master  ","id":8,"section":"posts","summary":"HUGO 글 생성하기 $ hugo new {파일명} HUGO 블로그 빌드 $ hugo -t {테마명} Git push $ cd public $ git add . $ git commit -m \u0026quot;{commit 메세지}\u0026quot; $ git push origin master $ cd .. $ git add . $ git commit -m \u0026quot;{commit 메","tags":["blog"],"title":"HUGO 블로그 새글 업로드하기","uri":"https://healinyoon.github.io/2020/08/20200827_hugo_blog/","year":"2020"},{"content":"Intro 이번 포스트에서는 CentOS에 Docker를 설치하는 방법을 정리했습니다.\n 1. Docker 설치하기 # yum 패키지 업데이트 yum update # docker, docker registry 설치 yum -y install docker docker-registry   2. Docker 실행 및 정보 확인 2-1. Docker 실행하기 # 시스템 부팅 시 docker를 시작하도록 설정 systemctl enable docker.service # Docker 실행 systemctl start docker.service # Docker 상태 확인 systemctl status docker.service  2-2. Docker 명령어 사용하기 Docker 명령어의 기본 형식은 docker {명령어} 입니다.\n# Docker 버전 확인 docker version # Docker 실행 환경 확인 docker system info # Docker 디스크 상태 확인 docker system df # 그 외 Docker 명령어 살펴보기 docker -help   3. Docker 사용해보기 Docker가 정상적으로 동작하는지 확인하기 위해 컨테이너를 실행합니다.\n3-1. Docker 컨테이너 실행하기 # Docker 컨테이너 실행 명령어 docker run {옵션} {컨테이너 명/ID}  docker run 명령어는 컨테이너를 생성하고 실행시키는 명령어 입니다. 이때 dockers는 로컬에 해당 이미지가 있는지 학인하고, 없는 경우 docker hub에서 pull을 먼저 진행하고 컨테이너를 생성합니다.\n3-2. Hello, world! docker run hello-world  hello-world 컨테이너가 실행되면 다음과 같이 메세지가 출력됩니다.\nHello from Docker! This message shows that your installation appears to be working correctly. To generate this message, Docker took the following steps: 1. The Docker client contacted the Docker daemon. 2. The Docker daemon pulled the \u0026quot;hello-world\u0026quot; image from the Docker Hub. (amd64) 3. The Docker daemon created a new container from that image which runs the executable that produces the output you are currently reading. 4. The Docker daemon streamed that output to the Docker client, which sent it to your terminal.  3-3. Nginx 이번에는 Nginx 웹서버를 docker로 설치해보겠습니다.\n# Nginx 이미지 다운로드 docker pull nginx # 다운로드한 이미지 확인 docker images # Nginx 컨테이너 실행 docker run --name nginx-webserver -d -p 80:80 nginx  docker run 명령어에서 자주 쓰이는 옵션은 다음과 같습니다.\n \u0026ndash;name: 컨테이너의 이름을 설정한다. -d: 컨테이너를 백그라운드에서 실행시킨다. -p: 호스트 포트와 컨테이너 내부의 포트를 매핑한다(형식: -p {host 포트}:{컨테이너 포트}).  실행중인 docker 컨테이너를 확인하고 싶을 때는 docker ps 명령어로 확인 할 수 있습니다.\n# 실행중인 컨테이너 확인 docker ps # 컨테이너 상태 확인 docker container stats  마지막으로 http://localhost:80으로 접속해서 Nginx 웹 브라우저를 확인합니다.\n 참고 사이트  https://niceman.tistory.com/36 https://futurecreator.github.io/2018/11/16/docker-container-basics/ http://pyrasis.com/Docker/Docker-HOWTO  ","id":9,"section":"posts","summary":"Intro 이번 포스트에서는 CentOS에 Docker를 설치하는 방법을 정리했습니다. 1. Docker 설치하기 # yum 패키지 업데이트 yum update # docker, docker registry 설치 yum -y install docker docker-registry 2. Docker 실행 및","tags":["msa"],"title":"Docker 설치하기(CentOS)","uri":"https://healinyoon.github.io/2019/06/20190611_docker_install/","year":"2019"}],"tags":[{"title":"blog","uri":"https://healinyoon.github.io/tags/blog/"},{"title":"ci/cd","uri":"https://healinyoon.github.io/tags/ci/cd/"},{"title":"jvm","uri":"https://healinyoon.github.io/tags/jvm/"},{"title":"k8s","uri":"https://healinyoon.github.io/tags/k8s/"},{"title":"master-slave","uri":"https://healinyoon.github.io/tags/master-slave/"},{"title":"msa","uri":"https://healinyoon.github.io/tags/msa/"},{"title":"pod networks","uri":"https://healinyoon.github.io/tags/pod-networks/"}]}